import distro

def read_vulnerability_database(file_path):
    vulnerabilities = []
    with open(file_path, 'r') as file:
        for line in file:
            # Разбиваем строку по точке с запятой на отдельные значения
            cve_id, distro_name, distro_version, package_name, fixed_version = line.strip().split(';')
            
            # Создаем словарь с информацией о уязвимости и добавляем его в список vulnerabilities
            vulnerabilities.append({
                'cve_id': cve_id,
                'distro_name': distro_name,
                'distro_version': distro_version,
                'package_name': package_name,
                'fixed_version': fixed_version
            })
    
    return vulnerabilities


def determine_os():
    # Получаем информацию о дистрибутиве с помощью модуля distro
    distro_info = distro.linux_distribution()
    
    # Проверяем, что дистрибутив - Ubuntu 20.04
    if distro_info[0] == 'Ubuntu' and distro_info[1] == '20.04':
        return distro_info[0], distro_info[1]
    
    # Если дистрибутив не соответствует ожидаемому, выбрасываем исключение
    raise Exception('Failed to determine the OS. The script should be run on Ubuntu 20.04.')


def get_installed_packages():
    # Читаем содержимое файла /var/lib/dpkg/status
    with open('/var/lib/dpkg/status', 'r') as file:
        status = file.read()

    packages = []
    current_package = None
    for line in status.split('\n'):
        line = line.strip()
        if line.startswith('Package:'):
            # Если строка начинается с "Package:", то получаем имя пакета
            current_package = line.split('Package:')[1].strip()
        elif line.startswith('Version:'):
            if current_package:
                # Если строка начинается с "Version:", то получаем версию пакета
                version = line.split('Version:')[1].strip()
                packages.append({
                    'package_name': current_package,
                    'version': version
                })
                current_package = None
    
    return packages


def find_vulnerable_packages(vulnerabilities, installed_packages):
    vulnerable_packages = []
    for installed_package in installed_packages:
        for vulnerability in vulnerabilities:
            # Проверяем, соответствует ли пакет критериям уязвимости
            if vulnerability['distro_name'] == 'Ubuntu' and \
                    vulnerability['distro_version'] == '20.04' and \
                    installed_package['package_name'] == vulnerability['package_name'] and \
                    installed_package['version'] < vulnerability['fixed_version']:
                # Если пакет уязвим, добавляем его в список уязвимых пакетов
                vulnerable_packages.append({
                    'package_name': installed_package['package_name'],
                    'installed_version': installed_package['version'],
                    'vulnerability': vulnerability['cve_id']
                })
    
    return vulnerable_packages


def main():
    vulnerability_file = 'vulnerability_database.txt'

    try:
        # Определяем операционную систему
        os_name, os_version = determine_os()
        print(f'Running on {os_name} {os_version}')

        # Читаем базу данных уязвимостей
        vulnerabilities = read_vulnerability_database(vulnerability_file)

        # Получаем установленные пакеты
        installed_packages = get_installed_packages()

        # Ищем уязвимые пакеты
        vulnerable_packages = find_vulnerable_packages(vulnerabilities, installed_packages)

        if vulnerable_packages:
            print('Vulnerable packages:')
            for package in vulnerable_packages:
                print(f'Package: {package["package_name"]}')
                print(f'Installed Version: {package["installed_version"]}')
                print(f'Vulnerability: {package["vulnerability"]}')
                print('---')
        else:
            print('No vulnerabilities found.')

    except Exception as e:
        print(e)


if __name__ == '__main__':
    main()